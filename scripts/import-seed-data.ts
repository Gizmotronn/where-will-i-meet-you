/** * Import transit stops from seed data * This script reads from the seeds/transit-stops.json file and imports into Convex */import { ConvexHttpClient } from "convex/browser";import { api } from "../packages/backend/convex/_generated/api";import fs from 'fs';import path from 'path';interface TransitStop {  name: string;  type: "train" | "tram";  city: string;  line: string;  distanceFromCity: number;  zone: number;  coordinates?: { lat: number; lng: number };  accessibility?: boolean;}interface SeedMetadata {  exportedAt: string;  description: string;  totalStops: number;}const client = new ConvexHttpClient(process.env.VITE_CONVEX_URL || "http://127.0.0.1:3210");async function importSeedData(): Promise<void> {  console.log("🌱 Importing transit stops from seed data...");  try {    // Read seed data    const seedPath = path.join(process.cwd(), 'seeds', 'transit-stops.json');    const metadataPath = path.join(process.cwd(), 'seeds', 'transit-stops-metadata.json');    if (!fs.existsSync(seedPath)) {      console.error(`❌ Seed file not found: ${seedPath}`);      console.log("Run 'npm run seed:export' first to create seed data.");      process.exit(1);    }    const stopsData: TransitStop[] = JSON.parse(fs.readFileSync(seedPath, 'utf8'));    const metadata: SeedMetadata | null = fs.existsSync(metadataPath)       ? JSON.parse(fs.readFileSync(metadataPath, 'utf8'))      : null;    console.log(`📖 Found ${stopsData.length} stops in seed data`);        if (metadata) {      console.log(`📅 Seed data from: ${new Date(metadata.exportedAt).toLocaleDateString()}`);      console.log(`📊 ${metadata.description}`);    }    // Option to clear existing data    const shouldClear = process.argv.includes('--clear');    if (shouldClear) {      console.log("🗑️  Clearing existing stops...");      const result = await client.mutation(api.stops.clearAll);      console.log(`🧹 Cleared ${result.deleted} existing stops`);    }    // Import in batches    const batchSize = 50;    let imported = 0;    let skipped = 0;    for (let i = 0; i < stopsData.length; i += batchSize) {      const batch = stopsData.slice(i, i + batchSize);            console.log(`Importing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(stopsData.length / batchSize)}...`);            for (const stop of batch) {        try {          await client.mutation(api.stops.create, stop);          imported++;        } catch (error: any) {          if (error.message?.includes('already exists')) {            skipped++;          } else {            console.error(`Error importing ${stop.name}:`, error.message || error);          }        }      }            // Small delay between batches      await new Promise(resolve => setTimeout(resolve, 100));    }    console.log('');    console.log('✅ Import complete!');    console.log(`  📥 Imported: ${imported} stops`);    console.log(`  ⏭️  Skipped (duplicates): ${skipped} stops`);    console.log(`  📊 Total processed: ${imported + skipped} stops`);    // Verify the import    console.log('');    console.log('🔍 Verification: Database now contains', (await client.query(api.stops.list)).length, 'stops');  } catch (error: any) {    console.error('❌ Import failed:', error.message || error);    process.exit(1);  }}

// Run the import
importSeedData().catch(console.error);
